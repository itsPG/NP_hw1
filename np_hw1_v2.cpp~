#include <iostream>
#include <sstream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <unistd.h>
#include <errno.h>
#include <wait.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <ctype.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <map>
#include <signal.h>
#define ROOT_DIC "/home/PG/PG/"
#define DEBUG 0
#define PIPEMAX 100000
#define PIPEADD 10000000
using namespace std;
void welcome_msg()
{
	cout << "****************************************" << endl;
	cout << "** Welcome to the information server. **" << endl;
	cout << "****************************************" << endl;
}
string i2s(int q)
{
	ostringstream sout;
	sout << q;
	return sout.str();
}
int s2i(string q)
{
	int r;
	istringstream ssin(q);
	ssin >> r;
	return r;
}
class PG_pipe
{
public:
	struct pipe_unit
	{
		int fd[2];
		int flag;
		pipe_unit(){flag = 0;}
		
	};

	map<int, pipe_unit> p_table;
	map<int, int> relation, fd_table;

	map<int, pipe_unit>::iterator iter,iter2;
	PG_pipe()
	{
		fd_table[0] = -1;
		fd_table[1] = -1;
		fd_table[2] = -1;
	}
	void show()
	{

		map<int,int>::iterator i;
		cerr << "pid " << getpid() << endl;
		for (i = fd_table.begin(); i != fd_table.end(); ++i)
		{
			
			if (i->second != 0)cerr << i->first << " " << i->second << endl;
		}
	}
	void create(int q)
	{
		if (p_table.find(q) != p_table.end()) return;
		
		pipe(p_table[q].fd);
		fd_table[p_table[q].fd[0]] = p_table[q].fd[0];
		fd_table[p_table[q].fd[1]] = p_table[q].fd[1];
		//cerr << "get" << p_table[q].fd[0] << " " << p_table[q].fd[1] << endl;
	}
	void close2(int q)
	{
		//cerr << "pid " << getpid() << " close " << q << endl;
		close(q);
		fd_table[q] = 0;
	}
	void dup22(int a,int b)
	{
		//cerr << "pid " << getpid() << " dup " << a << " to " << b <<endl;
		dup2(a,b);
		fd_table[b] = a;
	}
	void clean_pipe()
	{
		map<int,int>::iterator i;
		for (i = fd_table.begin(); i != fd_table.end(); ++i)
		{
			
			if (i->second > 2)
				close2(i->second);
		}
	}
	void fix_stdin(int q)
	{
		
		iter = p_table.find(q);
		if (iter == p_table.end())
		{
			//cerr << "fix_stdin cant find pipe " << q << endl;
			return;
		}
		close2(0);
		dup22(iter->second.fd[0], 0);
		close2(iter->second.fd[0]);

	}
	void fix_stdout(int q,int fix_stderr)
	{
		int aim = relation[q];
		iter = p_table.find(aim);
		if (iter == p_table.end())
		{
			//cerr << "fix_stdout cant find pipe " << aim << endl;
			return;
		}
		close2(1);
		dup22(iter->second.fd[1], 1);
		if (fix_stderr) dup22(iter->second.fd[1], 2);
		close2(iter->second.fd[1]);
		
	}
	void fix_main(int q)
	{
		iter = p_table.find(q);
		if (iter == p_table.end())
		{
			//cerr << "fix_main cant find pipe " << q << endl;
			return;
		}
		close2(iter->second.fd[0]);
		close2(iter->second.fd[1]);
	}
	void connect(int a, int b)
	{
		//cerr << "connect " << a << " to " << b << endl;
		relation[a] = b;
		create(b);
		
	}
	int chk_connect(int q){return relation[q];}
	void redirect_to_file(string fn)
	{
		int fd = open(fn.c_str(),O_WRONLY | O_CREAT | O_TRUNC,700);
		close2(1);
		dup22(fd,1);
		close2(fd);
	}
	
};
class PG_cmd
{
public:
	string cmd;
	vector<string> list, process_name;
	string PATH[101];
	vector<int> pipe_seg;
	map<string, string> ENV;
	int delay, delay_type;
	int seq_no, PATH_size;
	string prefix;
	string redirect_from, redirect_to; 
	int size;
	bool exit_flag, pipe_err_flag;
	
	PG_cmd()
	{
		size = 0;
		redirect_from = "";
		redirect_to = "";
		prefix = "cmd_";
		exit_flag = 0;
		pipe_err_flag = 0;
		
		PATH[0] = "bin";
		PATH[1] = "bin"; 
		PATH_size = 1;
		ENV["PATH"] = "bin";
	}
	void read()
	{
		getline(cin, cmd);
	}
	void parse()
	{
		string tmp = "";
		redirect_to = "";
		delay = 0;
		list.clear();
		for (int i = 0; i < cmd.size(); i++)
		{
			if (cmd[i] == ' ' || cmd[i] == '\t' || cmd[i] == '\n' || cmd[i] == '\r')
			{
				if (tmp != "")
				{
					list.push_back(tmp);
					tmp = "";
				}
			}
			else tmp += cmd[i];
		}
		if (tmp != "")list.push_back(tmp);
		
		for (int i = 0; i < list.size(); i++)
		{
			if(list[i] == ">")
			{
				redirect_to = list[i+1];
				list.erase(list.begin() + i); list.erase(list.begin() + i);
				//cerr << "Redirect to " << redirect_to << endl;
			}
		} 
		
		int end = list.size() - 1;
		if(list[end][0] =='|' || list[end][0] == '!')
		{
			if (list[end][0] == '!') pipe_err_flag = 1;
			list[end][0]=' ';
			delay = s2i(list[end]);
			list.erase(list.begin() + end);
		}
		//cerr << "after erase" << endl;
		pipe_seg.clear();
		pipe_seg.push_back(-1);
		for (int i = 1; i < list.size(); i++)
		{	
			if (list[i] == "|")
			{
				pipe_seg.push_back(i);
			}			
		}
		pipe_seg.push_back(list.size());
		
		string seq_no2 = i2s(seq_no);
		process_name.clear();
		process_name.push_back(prefix + seq_no2);
		for (int i = 2; i < pipe_seg.size(); i++)
		{	
			process_name.push_back(prefix + seq_no2 + "_" + i2s(i));	
		}
		if (list[0] == "exit")
		{
			exit_flag = 1;
		}
		if (0)
		{
			cout << "seg_size " << pipe_seg.size() << endl;
			cout << "process_name_size " << process_name.size() << endl;
			for (int i = 0; i < process_name.size(); i++)
				cout << process_name[i] << " " << pipe_seg[i]+1 << " " << pipe_seg[i+1]-1 << endl;
		}
		
	}
	void show()
	{
		cerr << "size " << list.size() << endl;
		for (int i = 0; i < list.size(); i++)
		cout << list[i] << endl;
	}
	void exec(int from, int to)
	{
		if (list[from] == "setenv")
		{
			ENV[list[from+1]] = list[from+2];
			if (list[from+1] != "PATH")return;
			PATH[0] = list[from+2];
			PATH_size = 0;
			for (int i = 0; i < PATH[0].size(); i++)
			{
				PATH[++PATH_size] = "";
				while (i < PATH[0].size() && PATH[0][i] !=':')
				{
					PATH[PATH_size] += PATH[0][i];
					i++;
				} 
			}
			exit(0);
		}
		if (list[from] == "printenv")
		{
			cout << ENV[list[from+1]] << endl;
			exit(0);
			
		}
		struct stat statbuf;
		bool success_flag = 0;
		string aim;
		for (int i=1; i<=PATH_size; i++)
		{
			
			aim =ROOT_DIC + PATH[i] + "/" + list[from];
			//cerr << aim << endl;
			if (stat(aim.c_str(), &statbuf) == -1) continue;
			else
			{
				success_flag = 1;
				break;
			}
			
		}
		if (!success_flag)
		{
			cerr << "Unknown command: [" << list[from] << "]." << endl;
			exit(0);
		}
		//cerr << "this is " << getpid() << endl;
		char **tmp = new char*[1001];
		int i, cnt;
		if(from > to)return;
		//cerr << "from " << from << " to " << to << endl;
		for (i = from,cnt = 0; i <= to; i++,cnt++)
		{
			//cerr << "use " << list[i] << "at" << i <<endl;
			tmp[cnt] = new char[1001];
			strcpy(tmp[cnt], list[i].c_str());
		}
		tmp[cnt] = NULL;
		//cerr << i << " is setted NULL" << endl;
		//cerr << "s```````````````" << endl;
		//for (int i = 0; tmp[i] != NULL; i++)cerr << "execvp-- " << tmp[i] << endl;
		//cerr << "e```````````````" << endl;
		if (execv(aim.c_str(), tmp))
		{
			perror("excvp fail");
			exit(0);
		}
	}
	void exec() {exec(0,list.size()-1);}
	void exec_seg(int q){exec(pipe_seg[q]+1, pipe_seg[q+1]-1);}

};
class PG_process
{
public:
	map<string, string> pool;

	string pid;
	PG_process()
	{
		pid = "init";
		pool["init"] = "init";
	}
	int harmonics(string q)
	{
		int t_pid;
		//pool[q] = pool[pid] + "/" + q;
		//cout << q << " " << pid << endl;
		if (t_pid = fork())
		{
			//cerr << "child " << pool[q] << endl;
			return t_pid;
		}
		else
		{
			//cerr << "parent " << pool[pid] << endl;
			//pid = q;
			return 0;
		}
	}
	int harmonics(string q,int q2)
	{
		harmonics(q + "_" +i2s(q2));
	}
	int Wait()
	{
		int stat;
		wait(&stat);
	}
	string relation(){return pool[pid];}
	
	
	
};
class PG_TCP
{
public:
	int c_fd, l_fd, pid;
	int harmonics()
	{
		int pid, stat;
		if (pid = fork())
		{
			waitpid(pid, &stat, 0);
			return pid;
		}
		else
		{
			if (fork())
			{
				exit(0);
			}
			else return 0;
		}
	}
	void go()
	{
		struct sockaddr_in sin;
		struct sockaddr_in cin;
		
		socklen_t len;
		char buf[10000]; 
		char addr_p[INET_ADDRSTRLEN]; 
		int port = 7000;
		int n,r; 
       
		bzero(&sin, sizeof(sin)); 
		sin.sin_family = AF_INET; 
		sin.sin_addr.s_addr = INADDR_ANY; 
		sin.sin_port = htons(port);
    
		l_fd = socket(AF_INET, SOCK_STREAM, 0); 
		while(1)
		{
			r = bind(l_fd, (struct sockaddr *)&sin, sizeof(sin));
			cout << "bind: " << r << endl;
			if(r == 0)break;
			usleep(500000);
		}
		r = listen(l_fd, 10); 
		cout << "listen: " << r << endl;
		printf("waiting ...\n");
		while(1)
		{
			usleep(500000);
			c_fd = accept(l_fd, (struct sockaddr *) &cin, &len); 
			cout << "accept: " << c_fd << endl;
			if (pid = harmonics())
			{
				cout << "parent" << endl;
				close(c_fd);
			}
			else
			{
				close(l_fd);
				dup2(c_fd, 0);
				dup2(c_fd, 1);
				dup2(c_fd, 2);
				close(c_fd);
				return ;
			}
		}
	}
	~PG_TCP()
	{
		
	}
};
void pipe_exec(PG_pipe &Elie, PG_cmd &Tio, int from, int to)
{
	//cerr << "exec " << from << " " << to << endl;
	//sleep(1);
	PG_process Rixia;
	int pid;
	if (from == to)
	{
		Tio.exec_seg(from);
		//cerr << "exec " << from << endl;
		cerr << "error!" << endl;
		return;
	}
	int fd[2];
	pipe(fd);
	if(pid = Rixia.harmonics("pipe"))
	{
		close(fd[1]);
		close(0);
		dup2(fd[0],0);
		close(fd[0]);
		Rixia.Wait();
		pipe_exec(Elie,Tio,from+1,to);
		return ;
	}
	else
	{
		close(fd[0]);
		close(1);
		dup2(fd[1],1);
		close(fd[1]);
		Tio.exec_seg(from);
		//cerr << "exec " << from << endl;
		exit(0);
	}
}
int main()
{
	PG_pipe Elie;
	PG_cmd Tio;
	PG_process Rixia;
	int seq_no = 0,pid;
	PG_TCP Noel;
	chdir(ROOT_DIC);
	Noel.go();
	
	while (1)
	{
		//cout << "pid is " << getpid() << " % ";
		cout << "% ";
		Tio.seq_no = ++seq_no;
		Tio.read();
		Tio.parse();
		//Tio.show();	
		if (Tio.exit_flag) exit(0);
		
		int pipe_to = 0;
		if(Tio.delay) 
		{
			pipe_to = seq_no + Tio.delay;
			Elie.connect(seq_no, pipe_to);
		}
		
		if (pid = Rixia.harmonics(i2s(seq_no)))
		{
			Elie.fix_main(seq_no);
			Rixia.Wait();
		}
		else
		{
			Elie.fix_stdin(seq_no);
			if (Tio.pipe_err_flag)
				Elie.fix_stdout(seq_no,1);
			else
				Elie.fix_stdout(seq_no,0);
			Elie.clean_pipe();
			if (Tio.redirect_to != "")
			{
				//cerr << "detect read" << endl;
				Elie.redirect_to_file(Tio.redirect_to);
			}
			
			if(Tio.pipe_seg.size() > 2)
			{
				pipe_exec(Elie, Tio, 0, Tio.pipe_seg.size()-2);
				exit(0);
				cerr << "failed to exit" << endl;
			}
			else
			{
				Tio.exec();
			}
		}
	}

	
}
